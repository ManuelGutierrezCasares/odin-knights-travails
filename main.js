import { getTravail, totalMoves } from './helpers.js';

// Main Function
function knightMoves (startPos, endPos) {
  // Validate inputs
  startPos.forEach(e => {
    if (e > 7 || e < 0) {
      throw new Error('Board can not be bigger than 8 nor smaller than 0');
    }
  });
  endPos.forEach(e => {
    if (e > 7 || e < 0) {
      throw new Error('Board can not be bigger than 8 nor smaller than 0');
    }
  });

  // Input display
  console.log(`Your input was: knightMoves([${startPos}],[${endPos}])`);

  // Declare array of moves
  const movesArr = [];
  // Declare Data Structure of moves object
  movesArr[0] = {
    position: endPos,
    distance: null,
    predecessor: null
  };

  // Variables distanceFound and currentDist are used to end loop when necessary
  let distanceFound = null;
  let currentDist = null;

  // Breadth-first search Algorithm
  const queue = [];
  queue.push([endPos, null]);
  while (queue.length !== 0 && distanceFound <= currentDist) {
    const current = queue.shift();
    const currentPos = current[0];
    currentDist = current[1];
    const movesAvailable = totalMoves(currentPos);
    const movesAmount = movesAvailable.length;

    for (let i = 0; i < movesAmount; i++) {
      const neighbour = {
        position: movesAvailable[i],
        distance: 1 + currentDist,
        predecessor: currentPos
      };
      movesArr.push(neighbour);
      queue.push([neighbour.position, neighbour.distance]);

      // Check if Starting position is found
      //   If so, end loop
      if (neighbour.position.toString() === startPos.toString()) {
        distanceFound = neighbour.distance;
      }
    }
  }

  // Get the Fastest Path among the Array of Objects generated by bfs
  const fastestPath = getTravail(movesArr, startPos);

  // Display amount of total moves necessary to get from startPos to endPos
  console.log(`=> You made it in ${fastestPath.length - 1} moves! Here's your path:`);

  // Display the Knights Travail each Tile at a time
  fastestPath.forEach(e => {
    console.log(`[${e.toString()}]`);
  });
}

// Tests
knightMoves([3, 1], [0, 7]);
knightMoves([0, 0], [3, 3]);
knightMoves([3, 3], [0, 0]);
knightMoves([0, 0], [7, 7]);
knightMoves([3, 3], [4, 3]);
